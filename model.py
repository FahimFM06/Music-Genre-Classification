# -*- coding: utf-8 -*-
"""model.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-CWPtFn-Epyu6AyqoLpwJf2RWJ_50GgK
"""

import torch
import torch.nn as nn


class CRNN_BiGRU(nn.Module):
    """
    CRNN for log-mel spectrogram classification:
      - CNN extracts time-frequency patterns
      - BiGRU models temporal dependencies across time
      - FC head outputs class logits
    Input: (B, n_mels, time_frames)
    """

    def __init__(
        self,
        num_classes: int,
        n_mels: int = 128,
        time_frames: int = 130,
        rnn_hidden: int = 128,
        dropout_cnn: float = 0.35,
    ):
        super().__init__()

        self.cnn = nn.Sequential(
            nn.Conv2d(1, 32, kernel_size=3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=(2, 2)),

            nn.Conv2d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=(2, 2)),

            nn.Conv2d(64, 128, kernel_size=3, padding=1),
            nn.BatchNorm2d(128),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=(2, 2)),

            nn.Dropout(dropout_cnn),
        )

        # Infer CNN output shape to set GRU input size robustly.
        with torch.no_grad():
            dummy = torch.zeros(1, 1, n_mels, time_frames)  # (B, C, H, W)
            out = self.cnn(dummy)
            _, c, h, w = out.shape
            gru_input_size = c * h
            self._cnn_out_w = w

        self.gru = nn.GRU(
            input_size=gru_input_size,
            hidden_size=rnn_hidden,
            num_layers=1,
            batch_first=True,
            bidirectional=True,
        )

        self.classifier = nn.Sequential(
            nn.Dropout(0.5),
            nn.Linear(2 * rnn_hidden, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, num_classes),
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        # x: (B, n_mels, time_frames)
        x = x.unsqueeze(1)             # (B, 1, n_mels, time)
        x = self.cnn(x)                # (B, Cc, Hc, Wc)

        b, c, h, w = x.shape
        x = x.permute(0, 3, 1, 2).contiguous()  # (B, Wc, Cc, Hc)
        x = x.view(b, w, c * h)                 # (B, Wc, Cc*Hc)

        out, _ = self.gru(x)         # (B, Wc, 2*rnn_hidden)
        out_last = out[:, -1, :]     # (B, 2*rnn_hidden)
        logits = self.classifier(out_last)
        return logits