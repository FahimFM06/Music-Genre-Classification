# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-CWPtFn-Epyu6AyqoLpwJf2RWJ_50GgK
"""

import io
import os
from typing import List, Tuple

import numpy as np
import streamlit as st
import torch

from model import CRNN_BiGRU
from audio_utils import (
    load_audio_fixed,
    extract_logmel_segments,
    TARGET_SR,
    TIME_FRAMES,
    N_MELS,
)

# -----------------------------
# Page config
# -----------------------------
st.set_page_config(page_title="Music Genre Classifier (CRNN-BiGRU)", layout="wide")

DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
MODEL_PATH = os.path.join( "best_crnn_bigru_pytorch.pt")

# Default GTZAN-like classes (edit to match your training label order)
DEFAULT_CLASSES = [
    "blues", "classical", "country", "disco", "hiphop",
    "jazz", "metal", "pop", "reggae", "rock"
]

# -----------------------------
# Styling (dashboard feel)
# -----------------------------
def inject_css() -> None:
    st.markdown(
        """
        <style>
          .kpi {
            padding: 16px 16px 14px 16px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.04);
          }
          .kpi .label { font-size: 13px; opacity: 0.80; }
          .kpi .value { font-size: 26px; font-weight: 800; margin-top: 4px; }
          .card {
            padding: 18px;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.03);
          }
          .muted { opacity: 0.80; }
          .tiny { font-size: 12px; opacity: 0.75; }
        </style>
        """,
        unsafe_allow_html=True,
    )

inject_css()

# -----------------------------
# Model loading
# -----------------------------
@st.cache_resource
def load_model_and_classes() -> Tuple[torch.nn.Module, List[str]]:
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(
            f"Model file not found: {MODEL_PATH}. Put it in the repo root (same folder as app.py)."
        )

    # You can optionally keep class names in a local file "classes.txt"
    # one class per line, to guarantee correct label order.
    classes_path = "classes.txt"
    if os.path.exists(classes_path):
        with open(classes_path, "r", encoding="utf-8") as f:
            classes = [ln.strip() for ln in f.readlines() if ln.strip()]
    else:
        classes = DEFAULT_CLASSES

    model = CRNN_BiGRU(num_classes=len(classes), n_mels=N_MELS, time_frames=TIME_FRAMES)
    state = torch.load(MODEL_PATH, map_location=DEVICE)

    # Works whether you saved raw state_dict or a dict with 'state_dict'
    if isinstance(state, dict) and "state_dict" in state:
        state = state["state_dict"]

    model.load_state_dict(state)
    model.to(DEVICE)
    model.eval()
    return model, classes


def predict_segments(logmel_segments: np.ndarray) -> np.ndarray:
    """
    logmel_segments: (S, N_MELS, TIME_FRAMES)
    returns probabilities: (S, num_classes)
    """
    model, _ = load_model_and_classes()
    x = torch.from_numpy(logmel_segments).to(DEVICE)  # (S, M, T)
    with torch.no_grad():
        logits = model(x)                             # (S, C)
        probs = torch.softmax(logits, dim=-1).cpu().numpy()
    return probs


# -----------------------------
# Plot helpers (matplotlib only)
# -----------------------------
def plot_waveform(y: np.ndarray, sr: int):
    import matplotlib.pyplot as plt

    t = np.arange(len(y)) / float(sr)
    fig = plt.figure()
    plt.plot(t, y)
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.title("Waveform (standardized to 30s)")
    st.pyplot(fig, clear_figure=True)


def plot_mel(logmel: np.ndarray, title: str):
    import matplotlib.pyplot as plt

    fig = plt.figure()
    plt.imshow(logmel, aspect="auto", origin="lower")
    plt.title(title)
    plt.xlabel("Time frames")
    plt.ylabel("Mel bins")
    st.pyplot(fig, clear_figure=True)


def render_topk(probs: np.ndarray, classes: List[str], k: int = 5):
    idx = np.argsort(probs)[::-1][:k]
    top = [(classes[i], float(probs[i])) for i in idx]
    st.write("**Top predictions**")
    for name, p in top:
        st.progress(min(max(p, 0.0), 1.0), text=f"{name}: {p*100:.2f}%")

# -----------------------------
# Sidebar (controls)
# -----------------------------
st.sidebar.title("Controls")
page = st.sidebar.radio("Navigation", ["Dashboard", "How it works", "About"], index=0)

with st.sidebar.expander("Inference settings", expanded=True):
    agg_method = st.selectbox("Aggregation", ["Mean (recommended)", "Median", "Max"], index=0)
    top_k = st.slider("Top-K display", 3, 10, 5, 1)
    show_segment_table = st.checkbox("Show per-segment table", value=True)
    show_wave = st.checkbox("Show waveform", value=True)
    show_mel_preview = st.checkbox("Show mel-spectrogram preview", value=True)

st.sidebar.markdown("---")
st.sidebar.caption("Tip: If your class order differs, create `classes.txt` in the repo (one class per line).")

# -----------------------------
# Pages
# -----------------------------
if page == "Dashboard":
    st.title("Music Genre Classification")
    st.write("Upload an audio file and get a genre prediction using your **CRNN + BiGRU (PyTorch)** model.")

    colA, colB, colC = st.columns(3)
    with colA:
        st.markdown(
            f'<div class="kpi"><div class="label">Device</div><div class="value">{DEVICE.type.upper()}</div></div>',
            unsafe_allow_html=True
        )
    with colB:
        st.markdown(
            f'<div class="kpi"><div class="label">Input spec</div><div class="value">{N_MELS}×{TIME_FRAMES}</div></div>',
            unsafe_allow_html=True
        )
    with colC:
        st.markdown(
            f'<div class="kpi"><div class="label">Segments per track</div><div class="value">10</div></div>',
            unsafe_allow_html=True
        )

    st.markdown("---")

    uploaded = st.file_uploader("Upload audio (wav/mp3/ogg)", type=["wav", "mp3", "ogg", "flac", "m4a"])
    if uploaded is None:
        st.info("Upload an audio file to enable inference.")
        st.stop()

    # Read bytes, pass to librosa via BytesIO
    audio_bytes = uploaded.read()
    st.audio(audio_bytes)

    try:
        model, classes = load_model_and_classes()

        with st.spinner("Preprocessing audio (30s standardization + log-mel segments)..."):
            y = load_audio_fixed(io.BytesIO(audio_bytes), sr=TARGET_SR)
            segments = extract_logmel_segments(y)  # (10, 128, 130)

        # Tabs
        tab1, tab2, tab3 = st.tabs(["Prediction", "Signal analysis", "Segment breakdown"])

        with tab1:
            with st.spinner("Running model inference..."):
                seg_probs = predict_segments(segments)   # (10, C)

            # aggregate
            if agg_method.startswith("Mean"):
                agg = seg_probs.mean(axis=0)
            elif agg_method == "Median":
                agg = np.median(seg_probs, axis=0)
            else:
                agg = seg_probs.max(axis=0)

            pred_idx = int(np.argmax(agg))
            pred_name = classes[pred_idx]
            pred_conf = float(agg[pred_idx])

            c1, c2 = st.columns([1.2, 1])
            with c1:
                st.markdown('<div class="card">', unsafe_allow_html=True)
                st.subheader("Final Prediction")
                st.write(f"**Genre:** {pred_name}")
                st.write(f"**Confidence:** {pred_conf*100:.2f}%")
                st.caption("Confidence is computed after aggregating probabilities across segments.")
                st.markdown("</div>", unsafe_allow_html=True)

            with c2:
                st.markdown('<div class="card">', unsafe_allow_html=True)
                st.subheader("Top-K")
                render_topk(agg, classes, k=top_k)
                st.markdown("</div>", unsafe_allow_html=True)

        with tab2:
            left, right = st.columns(2)
            with left:
                if show_wave:
                    st.markdown('<div class="card">', unsafe_allow_html=True)
                    st.subheader("Waveform")
                    plot_waveform(y, TARGET_SR)
                    st.markdown("</div>", unsafe_allow_html=True)

            with right:
                if show_mel_preview:
                    st.markdown('<div class="card">', unsafe_allow_html=True)
                    st.subheader("Log-mel preview (segment 1)")
                    plot_mel(segments[0], "Normalized log-mel (Segment 1)")
                    st.markdown("</div>", unsafe_allow_html=True)

        with tab3:
            with st.spinner("Preparing segment breakdown..."):
                seg_top = np.argmax(seg_probs, axis=1)
                seg_conf = np.max(seg_probs, axis=1)

            st.subheader("Per-segment predictions (10 × 3 seconds)")

            if show_segment_table:
                import pandas as pd
                df = pd.DataFrame({
                    "Segment": [f"{i+1}" for i in range(len(seg_top))],
                    "Predicted genre": [classes[i] for i in seg_top],
                    "Confidence": [float(c) for c in seg_conf],
                })
                st.dataframe(df, use_container_width=True)

            st.write("**Segment confidence trend**")
            st.line_chart(seg_conf)

    except Exception as e:
        st.error("Inference failed. Check the error details below.")
        st.code(str(e))

elif page == "How it works":
    st.title("How it works")
    st.markdown(
        """
        **Pipeline**
        1. Audio is resampled to **22,050 Hz**, converted to mono, and standardized to **30 seconds**.
        2. The signal is split into **10 segments** of **3 seconds** each.
        3. For each segment, a **log-mel spectrogram** is computed with:
           - `n_fft=2048`, `hop_length=512`, `n_mels=128`
           - `center=True` → fixed **130 time frames**
        4. Each segment is normalized (zero-mean, unit-std).
        5. The model predicts probabilities per segment, then we aggregate them (Mean/Median/Max).
        """
    )
    st.info(
        "Important: class order must match training. If your label encoder order differs, create a `classes.txt` file."
    )

elif page == "About":
    st.title("About")
    st.markdown(
        """
        This Streamlit app is designed for your **CRNN + BiGRU PyTorch** checkpoint:
        - `best_crnn_bigru_pytorch.pt`

        **Deployment tips**
        - Add `requirements.txt`
        - Use Git LFS if the `.pt` file is large
        - Deploy on Streamlit Community Cloud or your own server
        """
    )