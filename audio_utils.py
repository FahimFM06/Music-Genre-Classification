# -*- coding: utf-8 -*-
"""audio_utils.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-CWPtFn-Epyu6AyqoLpwJf2RWJ_50GgK
"""

import numpy as np

# Core parameters (match training)
TARGET_SR = 22050
TRACK_DURATION = 30.0
SAMPLES_PER_TRACK = int(TARGET_SR * TRACK_DURATION)

SEGMENT_DURATION = 3.0
SEGMENT_SAMPLES = int(TARGET_SR * SEGMENT_DURATION)
SEGMENTS_PER_TRACK = int(TRACK_DURATION / SEGMENT_DURATION)  # 10

N_FFT = 2048
HOP_LENGTH = 512
N_MELS = 128

# With librosa center=True: frames = 1 + floor(SEGMENT_SAMPLES / HOP_LENGTH) = 130
TIME_FRAMES = 1 + (SEGMENT_SAMPLES // HOP_LENGTH)


def _safe_import_librosa():
    try:
        import librosa
        return librosa
    except Exception as e:
        raise RuntimeError(
            "librosa import failed. Fix by pinning versions in requirements.txt "
            "or use an environment where librosa works.\n\n"
            f"Original error: {e}"
        )


def load_audio_fixed(path_or_bytes, sr: int = TARGET_SR) -> np.ndarray:
    """
    Loads audio, resamples to TARGET_SR, converts to mono, then pads/trims to 30s.
    Accepts a file path or bytes-like object.
    """
    librosa = _safe_import_librosa()

    y, _sr = librosa.load(path_or_bytes, sr=sr, mono=True)

    if y is None or len(y) == 0:
        raise ValueError("Empty audio. Please upload a valid audio file.")

    # pad/trim to fixed 30s
    if len(y) > SAMPLES_PER_TRACK:
        y = y[:SAMPLES_PER_TRACK]
    elif len(y) < SAMPLES_PER_TRACK:
        y = np.pad(y, (0, SAMPLES_PER_TRACK - len(y)), mode="constant")

    return y.astype(np.float32)


def extract_logmel_segments(y: np.ndarray) -> np.ndarray:
    """
    Split 30s signal into 10 segments of 3s and compute normalized log-mel per segment.
    Returns: (segments, N_MELS, TIME_FRAMES)
    """
    librosa = _safe_import_librosa()

    feats = []
    for i in range(SEGMENTS_PER_TRACK):
        start = i * SEGMENT_SAMPLES
        end = start + SEGMENT_SAMPLES
        seg = y[start:end]

        # Safety: should always be exact length, but keep it robust
        if len(seg) < SEGMENT_SAMPLES:
            seg = np.pad(seg, (0, SEGMENT_SAMPLES - len(seg)), mode="constant")
        elif len(seg) > SEGMENT_SAMPLES:
            seg = seg[:SEGMENT_SAMPLES]

        mel = librosa.feature.melspectrogram(
            y=seg,
            sr=TARGET_SR,
            n_fft=N_FFT,
            hop_length=HOP_LENGTH,
            n_mels=N_MELS,
            center=True,
            power=2.0,
        )
        log_mel = librosa.power_to_db(mel, ref=np.max).astype(np.float32)

        # normalize per segment (same style you used)
        mean = float(log_mel.mean())
        std = float(log_mel.std() + 1e-8)
        log_mel = (log_mel - mean) / std

        # Ensure fixed (N_MELS, TIME_FRAMES)
        if log_mel.shape[1] < TIME_FRAMES:
            pad = TIME_FRAMES - log_mel.shape[1]
            log_mel = np.pad(log_mel, ((0, 0), (0, pad)), mode="constant")
        elif log_mel.shape[1] > TIME_FRAMES:
            log_mel = log_mel[:, :TIME_FRAMES]

        feats.append(log_mel)

    return np.stack(feats, axis=0).astype(np.float32)


def softmax(x: np.ndarray, axis: int = -1) -> np.ndarray:
    x = x - np.max(x, axis=axis, keepdims=True)
    e = np.exp(x)
    return e / (np.sum(e, axis=axis, keepdims=True) + 1e-12)